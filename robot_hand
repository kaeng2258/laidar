import tkinter as tk
from tkinter import messagebox, ttk
import serial
import time

class SbotSampleApp:
    def __init__(self, root):
        self.root = root
        self.root.title("SbotSample")
        self.root.geometry("400x400")
        
        self.speed = 3
        self.init_angle = [0.0, 0.0, 90.0, 0.0, 45.0]  # Default angles, including 45 for the gripper
        self.dest_angle = [0.0, 0.0, 0.0, 0.0, 0.0]
        
        self.serial_port = serial.Serial(baudrate=57600, timeout=1)
        self.create_widgets()
        
    def create_widgets(self):
        frame = ttk.Frame(self.root, padding="10")
        frame.pack(fill="both", expand=True)

        # Port selection
        ttk.Label(frame, text="Select Port:").grid(row=0, column=0, pady=5, sticky="e")
        self.cb_port = tk.StringVar()
        self.cb_port_menu = ttk.Combobox(frame, textvariable=self.cb_port, values=self.get_ports(), state="readonly")
        self.cb_port_menu.grid(row=0, column=1, pady=5, sticky="w")
        self.cb_port_menu.set("Select Port")

        self.lb_state = ttk.Label(frame, text="Disconnected")
        self.lb_state.grid(row=0, column=2, pady=5, sticky="w")

        # Speed input
        ttk.Label(frame, text="Speed (1-5):").grid(row=1, column=0, pady=5, sticky="e")
        self.tb_speed = ttk.Entry(frame)
        self.tb_speed.insert(0, "3")
        self.tb_speed.grid(row=1, column=1, pady=5, sticky="w")

        # Angle entries with min/max labels
        angle_limits = [(-80, 80), (-80, 80), (0, 170), (-90, 90), (35, 60)]
        labels = ["Angle 1", "Angle 2", "Angle 3", "Angle 4", "Gripper"]
        self.tb_angles = []

        for i, (label, (min_val, max_val)) in enumerate(zip(labels, angle_limits)):
            ttk.Label(frame, text=f"{label} ({min_val} to {max_val}):").grid(row=2+i, column=0, pady=5, sticky="e")
            tb = ttk.Entry(frame)
            tb.insert(0, str(self.init_angle[i]))
            tb.grid(row=2+i, column=1, pady=5, sticky="w")
            self.tb_angles.append(tb)

        # Buttons
        self.btn_connect = ttk.Button(frame, text="Connect", command=self.connect)
        self.btn_connect.grid(row=7, column=0, pady=10, sticky="e")

        self.btn_disconnect = ttk.Button(frame, text="Disconnect", command=self.disconnect)
        self.btn_disconnect.grid(row=7, column=1, pady=10, sticky="w")

        self.btn_go = ttk.Button(frame, text="Go", command=self.go)
        self.btn_go.grid(row=8, column=0, pady=10, sticky="e")

        self.btn_go_home = ttk.Button(frame, text="Go Home", command=self.go_home)
        self.btn_go_home.grid(row=8, column=1, pady=10, sticky="w")

        self.btn_set_origin = ttk.Button(frame, text="Set Origin Offset", command=self.set_origin_offset)
        self.btn_set_origin.grid(row=9, column=0, columnspan=2, pady=10)

        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def get_ports(self):
        import serial.tools.list_ports
        ports = serial.tools.list_ports.comports()
        return [port.device for port in ports]

    def connect(self):
        if not self.serial_port.is_open:
            port_name = self.cb_port.get()
            if port_name and port_name != "Select Port":
                self.serial_port.port = port_name
                self.serial_port.open()
                time.sleep(0.1)
                self.lb_state.config(text="Connected")

    def disconnect(self):
        if self.serial_port.is_open:
            self.serial_port.close()
            time.sleep(0.1)
            self.lb_state.config(text="Disconnected")

    def go(self):
        angle_limits = [(-80, 80), (-80, 80), (0, 170), (-90, 90), (35, 60)]
        labels = ["Angle 1", "Angle 2", "Angle 3", "Angle 4", "Gripper"]
        dest_val = [0, 0, 0, 0, 0]

        # Speed validation
        try:
            self.speed = int(self.tb_speed.get())
            if self.speed < 1 or self.speed > 5:
                raise ValueError("Speed must be between 1 and 5.")
        except ValueError as e:
            messagebox.showerror("Invalid Input", str(e))
            return

        # Angle validation
        for i in range(5):
            try:
                angle = float(self.tb_angles[i].get())
                min_val, max_val = angle_limits[i]
                if angle < min_val or angle > max_val:
                    raise ValueError(f"{labels[i]} must be between {min_val} and {max_val}.")
                self.dest_angle[i] = angle
            except ValueError as e:
                messagebox.showerror("Invalid Input", str(e))
                return

        for i in range(5):
            if i == 4:  # Special handling for the gripper
                # Convert the gripper angle: 0 (fully closed) to 70 (fully open)
                dest_val[i] = int(2350 - ((self.dest_angle[i] / 70.0) * (2350 - 550)))
            else:
                direction = -1 if i in [0, 1] else 1
                dest_val[i] = int(self.dest_angle[i] * direction * 10.0) + int(1450 - self.init_angle[i] * 10.0)

        if self.serial_port.is_open:
            send = bytearray(14)
            send[0] = ord('B')  # Command
            send[1] = self.speed
            for i in range(5):
                send[2 + i * 2] = (dest_val[i] >> 8) & 0xFF  # High byte
                send[3 + i * 2] = dest_val[i] & 0xFF  # Low byte

            self.serial_port.write(send)

    def go_home(self):
        for i in range(5):
            self.tb_angles[i].delete(0, tk.END)
            self.tb_angles[i].insert(0, str(self.init_angle[i]))

        self.go()

    def set_origin_offset(self):
        if messagebox.askyesno("Set Origin Offset", "경고!! 로봇의 원점의 위치를 바꿉니다."):
            if self.serial_port.is_open:
                send = bytearray(14)
                send[0] = ord('C')  # Command
                self.serial_port.write(send)

    def on_closing(self):
        if self.serial_port.is_open:
            self.serial_port.close()
        self.root.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    app = SbotSampleApp(root)
    root.mainloop()
